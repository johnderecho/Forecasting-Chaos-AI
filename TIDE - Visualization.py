# Imports:

import os
import json
import gzip
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings

# Attempt to import dysts modules if available, as they are used later
try:
    import dysts.flows as dfl
    import dysts.graphics as dg
except ImportError:
    pass


GRANULARITY = 100

# FIX: Define fg_color to prevent NameError in plotting sections later
fg_color = (0, 0, 0)

#with gzip.open(os.getcwd() + "/results/results_neural_ode_multivariate.json.gz","r") as file:
#    all_results2 = json.load(file)      # results neural ODE

# FIX: Use standard open() for the plain .json file generated by the training script
with open(r"C:\Users\Windows\Desktop\Derecho - Thesis\1. Code\results\results_optuna_tide.json", "r") as file:
    tide_results = json.load(file)      # results neural ODE


all_scores = dict()
for key in tide_results.keys():
    if key not in tide_results.keys():
        continue
    all_scores[key] = dict()
    
    # Loop through models (TiDE_final, TiDE_dim0, etc.)
    for model_name in tide_results[key].keys():
        # Skip metadata and raw data keys
        if model_name in ["values", "optuna_summary"]:
            continue
            
        # Handle different result structures (nested metrics vs flat)
        result_data = tide_results[key][model_name]
        
        if "smape" in result_data:
            all_scores[key][model_name] = result_data["smape"]
        elif "combined_metrics" in result_data and "smape" in result_data["combined_metrics"]:
            all_scores[key][model_name] = result_data["combined_metrics"]["smape"]
        elif "metrics" in result_data and "smape" in result_data["metrics"]:
            all_scores[key][model_name] = result_data["metrics"]["smape"]

    # The following are commented out because variables are undefined in the provided snippet
    # all_scores[key]["nODE"] = all_results2[key]["smape"]                       # NODE test
    # all_scores[key]["ESN"] = all_results_esn[key]["smape"]                     # ESN test
    # all_scores[key]["nVAR"] = all_results_nvar[key]["smape"]                   # nVAR test


all_scores = pd.DataFrame(all_scores).transpose()
all_scores_dict = all_scores.to_dict()

print(all_scores.shape)

# find mean and sort to get column names
mean_scores = all_scores.median(axis=0)
sort_order = np.argsort(np.array(mean_scores))
mean_scores = mean_scores.sort_values()
models_ranked = list(mean_scores.index)

# FIX: 'rename_models' is not defined, so we comment it out to prevent a crash.
# all_scores_dict = rename_models(all_scores_dict)





## Create a ranking of equations based on the SMAPE of the TIDE Model
equation_names =  np.array(list(tide_results.keys()))
all_errs = []
ranking_model = "TiDE_final"

for equation_name in tide_results:
    if ranking_model in tide_results[equation_name]:
        # Extract SMAPE from the nested structure
        all_errs.append(tide_results[equation_name][ranking_model]["combined_metrics"]["smape"])
    else:
        # If the model didn't run for this equation, append infinity to put it last
        all_errs.append(np.inf)

equation_names = equation_names[np.argsort(np.array(all_errs))]

## Get the data to lookup timescales
# cwd = os.getcwd()
# input_path = os.path.dirname(cwd)  + "/dysts/data/test_multivariate__pts_per_period_100__periods_12.json.gz"
# equation_data = load_file(input_path)

## Plot the forecasted equations (removed top 10 limit)
model_name = "TiDE_final"
window = 1000

for equation_name in equation_names:
    # Ensure dfl is available or this will fail
    if 'dfl' in globals():
        eq = getattr(dfl, equation_name)()
        lyap = eq.maximum_lyapunov_estimated
        print(lyap)

        tt, _ = eq.make_trajectory(
            1000, resample=True, return_times=True, pts_per_period=100
        )
        dtval = np.median(np.diff(tt))

    else:
        print(f"dysts.flows not imported, using placeholders for {equation_name}")
        lyap = 1.0
        dtval = 0.01

    if "values" not in tide_results[equation_name]:
        print(f"Skipping {equation_name}: 'values' not found in results.")
        continue

    true_values = np.array(tide_results[equation_name]["values"])
    prediction = np.array(tide_results[equation_name][model_name]["prediction"])

    tvals = np.arange(len(true_values))[-window:] * lyap * dtval

    window = 5000
    plt.figure(figsize=(6, 6))
    plt.plot(
        true_values[-window:, 0],
        true_values[-window:, 1],
        linewidth=2,
        zorder=-30,
        # color=list(fg_color) + [0.2] # fg_color undefined
        color=[0,0,0,0.2] 
    )
    # Check if color_dict is defined, otherwise use default
    c = 'blue'
    if 'color_dict' in globals() and model_name in color_dict:
        c = color_dict[model_name]
        
    plt.plot(
        prediction[-window:, 0],
        prediction[-window:, 1],
        color=c,
        linewidth=1,
        zorder=2
    )
    if 'dg' in globals():
        dg.fixed_aspect_ratio(1)
    plt.title(f"{equation_name} - {model_name}: Lyap = {lyap:.2f}")
    # dg.better_savefig(FIGPATH + f"attractor_examples_long_{equation_name}_{model_name}.png", dpi=800)

    # window = 1000
    # plt.figure(figsize=(12, 1.5))
    # plt.plot(
    #     tvals,
    #     true_values[-window:, 1],
    #     linewidth=4,
    #     zorder=-30,
    #     color=list(fg_color) + [0.2]
    # )
    # plt.plot(
    #     tvals,
    #     prediction[-window:, 1],
    #     color=color_dict[model_name],
    #     linewidth=2,
    #     zorder=2
    # )
    # plt.xlim([tvals[0], tvals[-1]])


    # plt.figure(figsize=(12, 1.5))
    # plt.plot(
    #     tvals,
    #     true_values[-window:, 0],
    #     linewidth=4,
    #     zorder=-30,
    #     color=list(fg_color) + [0.2]
    # )
    # plt.plot(
    #     tvals,
    #     prediction[-window:, 0],
    #     color=color_dict[model_name],
    #     linewidth=2,
    #     zorder=2
    # )
    # plt.xlim([tvals[0], tvals[-1]])

    window = 500
    tvals = np.arange(len(true_values))[:window] * lyap * dtval
    plt.figure(figsize=(5*1.3, 1.3))
    plt.plot(
        tvals,
        true_values[:window, 0],
        linewidth=5,
        zorder=-30,
        color=[0,0,0,0.2]
    )
    plt.plot(
        tvals,
        prediction[:window, 0],
        color=c,
        linewidth=3,
        zorder=2
    )
    plt.xticks(np.arange(100).astype(int))
    plt.gca().set_yticks([])
    plt.xlim([tvals[0], tvals[-1]])
    plt.title(f"{equation_name} - {model_name}: Lyap = {lyap:.2f}")
    # dg.better_savefig(FIGPATH + f"forecast_examples_long_{equation_name}_{model_name}_start.png", dpi=800)


    window = 500
    tvals = np.arange(len(true_values))[-window:] * lyap * dtval
    plt.figure(figsize=(5*1.3, 1.3))
    plt.plot(
        tvals,
        true_values[-window:, 0],
        linewidth=5,
        zorder=-30,
        color=list(fg_color) + [0.2]
    )
    plt.plot(
        tvals,
        prediction[-window:, 0],
        # FIX: Use 'c' (safe calculated color) instead of accessing potentially undefined color_dict
        color=c,
        linewidth=3,
        zorder=2
    )
    plt.xticks(np.arange(100).astype(int))
    plt.gca().set_yticks([])
    plt.xlim([tvals[0], tvals[-1]])
    plt.title(f"{equation_name} - {model_name}: Lyap = {lyap:.2f}")
    # dg.better_savefig(
    #     FIGPATH + f"forecast_examples_long_{equation_name}_{model_name}_end.png",
    #     dpi=800,
    #     dryrun=NOSAVEFIG
    # )

    # FIX: Explicitly show the plots so they appear on screen
    plt.show()
